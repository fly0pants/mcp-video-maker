import asyncio
import uuid
import json
from typing import Dict, List, Any, Optional, Union
from datetime import datetime
import logging
import os
import httpx
import warnings

from models.message import Message, MessageType, AgentType
from models.video import (
    Script, ScriptSection, Storyboard, StoryboardFrame, StoryboardImage, 
    StoryboardTransition, StoryboardStyle, StoryboardFrameType, 
    StoryboardImageSource, ShotType, TransitionType
)
from agents.base_agent import BaseAgent
from utils.file_manager import file_manager
from utils.logger import system_logger
from config.config import SYSTEM_CONFIG
import openai
from utils.prompt_manager import get_prompt_manager


class StoryboardAgent(BaseAgent):
    """
    分镜代理 - 系统的"分镜师"，负责生成故事预览和分镜图像
    
    职责:
    - 根据脚本内容，生成完整的分镜计划
    - 为每个分镜场景生成详细的视觉描述
    - 调用AI图像生成服务（如Replicate、豆包）创建分镜图像
    - 展示故事的视觉预览，帮助用户理解最终视频的效果
    
    @deprecated: 此版本的StoryboardAgent已被弃用，将被MCPStoryboardAgent替代。
    分镜内容不再由StoryboardAgent生成，而应由MCPContentAgent生成，再通过mcp_central_agent调用工作流传递。
    """
    
    def __init__(self):
        super().__init__(AgentType.STORYBOARD, "StoryboardAgent")
        self.openai_client = None
        self.httpx_client = None
        self.replicate_api_key = None
        self.douimg_api_key = None
        warnings.warn(
            "This version of StoryboardAgent is deprecated and will be replaced by MCPStoryboardAgent. "
            "Storyboard content should be generated by MCPContentAgent and passed through the MCP workflow.",
            DeprecationWarning,
            stacklevel=2
        )
        
    async def initialize(self):
        """初始化分镜代理"""
        await super().initialize()
        
        # 初始化OpenAI客户端
        api_key = SYSTEM_CONFIG.get("openai_api_key")
        if api_key:
            self.openai_client = openai.AsyncOpenAI(api_key=api_key)
            self.logger.info("OpenAI client initialized")
        else:
            self.logger.warning("OpenAI API key not found, some features may be limited")
        
        # 初始化HTTP客户端
        self.httpx_client = httpx.AsyncClient()
        
        # 获取图像生成API密钥
        self.replicate_api_key = SYSTEM_CONFIG.get("replicate_api_key")
        if not self.replicate_api_key:
            self.logger.warning("Replicate API key not found, Replicate image generation will be unavailable")
            
        self.douimg_api_key = SYSTEM_CONFIG.get("douimg_api_key")
        if not self.douimg_api_key:
            self.logger.warning("豆包 API key not found, 豆包 image generation will be unavailable")
        
        self.logger.info("Storyboard Agent initialized and ready to create storyboards")
        
    async def shutdown(self):
        """关闭分镜代理"""
        if self.httpx_client:
            await self.httpx_client.aclose()
        await super().shutdown()
        
    async def handle_command(self, message: Message) -> Optional[Message]:
        """处理命令消息"""
        action = message.content.get("action")
        
        if action == "create_storyboard":
            # 创建分镜
            script_data = message.content.get("script")
            storyboard_style = message.content.get("style", "storyboard")
            session_id = message.content.get("session_id")
            
            if not script_data:
                return self.create_error_response(message, "Missing script data")
                
            try:
                # 将脚本数据转换为Script对象
                script = Script(**script_data)
                
                # 生成分镜
                storyboard = await self._generate_storyboard(script, storyboard_style, session_id)
                
                # 保存分镜到文件
                storyboard_json = storyboard.model_dump_json(indent=2)
                file_path = await file_manager.save_json_file(
                    data=json.loads(storyboard_json),
                    filename=f"storyboard_{storyboard.id}.json",
                    session_id=session_id,
                    subdir="storyboards"
                )
                
                self.logger.info(f"Storyboard created and saved to {file_path}")
                
                return self.create_success_response(message, {
                    "storyboard": json.loads(storyboard_json),
                    "file_path": file_path
                })
            except Exception as e:
                self.logger.error(f"Error creating storyboard: {str(e)}")
                return self.create_error_response(message, f"Error creating storyboard: {str(e)}")
                
        elif action == "generate_storyboard_images":
            # 为分镜生成图像
            storyboard_data = message.content.get("storyboard")
            image_source = message.content.get("image_source", "replicate")
            image_model = message.content.get("image_model")
            session_id = message.content.get("session_id")
            frames_to_generate = message.content.get("frames", [])
            
            if not storyboard_data:
                return self.create_error_response(message, "Missing storyboard data")
                
            try:
                # 将分镜数据转换为Storyboard对象
                storyboard = Storyboard(**storyboard_data)
                
                # 根据所选来源生成分镜图像
                updated_storyboard = await self._generate_storyboard_images(
                    storyboard, 
                    image_source,
                    image_model,
                    session_id,
                    frames_to_generate
                )
                
                # 保存更新后的分镜到文件
                storyboard_json = updated_storyboard.model_dump_json(indent=2)
                file_path = await file_manager.save_json_file(
                    data=json.loads(storyboard_json),
                    filename=f"storyboard_{updated_storyboard.id}_with_images.json",
                    session_id=session_id,
                    subdir="storyboards"
                )
                
                self.logger.info(f"Storyboard with images saved to {file_path}")
                
                return self.create_success_response(message, {
                    "storyboard": json.loads(storyboard_json),
                    "file_path": file_path
                })
            except Exception as e:
                self.logger.error(f"Error generating storyboard images: {str(e)}")
                return self.create_error_response(message, f"Error generating storyboard images: {str(e)}")
                
        elif action == "revise_storyboard":
            # 修改分镜
            storyboard_data = message.content.get("storyboard")
            feedback = message.content.get("feedback")
            session_id = message.content.get("session_id")
            
            if not storyboard_data or not feedback:
                return self.create_error_response(message, "Missing storyboard data or feedback")
                
            try:
                # 将分镜数据转换为Storyboard对象
                storyboard = Storyboard(**storyboard_data)
                
                # 根据反馈修改分镜
                revised_storyboard = await self._revise_storyboard(storyboard, feedback, session_id)
                
                # 保存修改后的分镜到文件
                storyboard_json = revised_storyboard.model_dump_json(indent=2)
                file_path = await file_manager.save_json_file(
                    data=json.loads(storyboard_json),
                    filename=f"storyboard_{revised_storyboard.id}_revised.json",
                    session_id=session_id,
                    subdir="storyboards"
                )
                
                self.logger.info(f"Storyboard revised and saved to {file_path}")
                
                return self.create_success_response(message, {
                    "storyboard": json.loads(storyboard_json),
                    "file_path": file_path
                })
            except Exception as e:
                self.logger.error(f"Error revising storyboard: {str(e)}")
                return self.create_error_response(message, f"Error revising storyboard: {str(e)}")
                
        else:
            return self.create_error_response(message, f"Unknown action: {action}")
            
    async def _generate_storyboard(self, script: Script, style: str, session_id: str) -> Storyboard:
        """
        根据脚本生成分镜
        
        Args:
            script: 脚本对象
            style: 分镜风格
            session_id: 会话ID
            
        Returns:
            生成的分镜对象
        """
        self.logger.info(f"Generating storyboard for script: {script.id} with style: {style}")
        
        # 获取提示管理器
        prompt_manager = get_prompt_manager()
        
        # 准备生成分镜的提示参数
        script_sections_content = ""
        for section in script.sections:
            script_sections_content += f"场景 {section.order + 1}:\n"
            script_sections_content += f"内容: {section.content}\n"
            script_sections_content += f"视觉描述: {section.visual_description}\n"
            if section.audio_description:
                script_sections_content += f"音频描述: {section.audio_description}\n"
            script_sections_content += "\n"
        
        prompt_params = {
            "title": script.title,
            "theme": script.theme,
            "type": script.type,
            "style": style,
            "duration": script.total_duration,
            "script_content": script_sections_content,
            "storyboard_style": style
        }
        
        # 使用OpenAI生成分镜内容
        if self.openai_client:
            try:
                # 渲染提示模板
                prompt = prompt_manager.render_template(
                    "storyboard_agent_prompts", 
                    "create_storyboard", 
                    prompt_params
                )
                system_role = prompt_manager.get_system_role("storyboard_agent_prompts", "create_storyboard")
                
                # 调用OpenAI API
                response = await self.openai_client.chat.completions.create(
                    model="gpt-4",
                    messages=[
                        {"role": "system", "content": system_role},
                        {"role": "user", "content": prompt}
                    ],
                    temperature=0.7,
                    max_tokens=4000
                )
                
                storyboard_text = response.choices[0].message.content
                
                # 解析AI生成的分镜文本，创建Storyboard对象
                storyboard_id = f"storyboard_{uuid.uuid4().hex[:8]}"
                
                # 解析生成的分镜内容，创建帧列表
                frames = await self._parse_storyboard_text(storyboard_text, script)
                
                # 计算总时长
                total_duration = sum(frame.duration for frame in frames)
                
                # 创建Storyboard对象
                storyboard = Storyboard(
                    id=storyboard_id,
                    script_id=script.id,
                    title=f"{script.title} Storyboard",
                    style=StoryboardStyle(style),
                    frames=frames,
                    transitions=[],  # 初始时没有转场特效
                    images=[],  # 初始时没有图像
                    total_duration=total_duration,
                    creator_id=script.creator_id,
                    status="draft",
                    metadata={
                        "generated_text": storyboard_text,
                        "generation_time": datetime.now().isoformat()
                    }
                )
                
                return storyboard
                
            except Exception as e:
                self.logger.error(f"Error generating storyboard with OpenAI: {str(e)}")
                raise
        else:
            # 如果没有OpenAI客户端，使用模拟数据
            return self._generate_mock_storyboard(script, style)
    
    async def _parse_storyboard_text(self, storyboard_text: str, script: Script) -> List[StoryboardFrame]:
        """
        解析生成的分镜文本，创建帧列表
        
        Args:
            storyboard_text: AI生成的分镜文本
            script: 脚本对象
            
        Returns:
            分镜帧列表
        """
        frames = []
        
        # 使用OpenAI辅助解析复杂文本
        if self.openai_client:
            try:
                prompt = f"""请将以下分镜文本解析为JSON格式的帧列表。每个帧应包含以下属性：
                1. frame_type (类型为 keyframe, establishing, closeup, action, transition, dialogue, narrative 之一)
                2. shot_type (类型为 wide, medium, close_up, extreme_close_up, aerial, pov, tracking, static, handheld, dolly 之一)
                3. description (帧的描述)
                4. visual_description (视觉细节描述)
                5. dialogue (对白内容，如果有)
                6. duration (持续时间，以秒为单位)
                
                分镜文本：
                {storyboard_text}
                
                请以有效的JSON数组格式输出，确保每个字段都有合适的值。duration应该是一个数字。"""
                
                response = await self.openai_client.chat.completions.create(
                    model="gpt-4",
                    messages=[
                        {"role": "system", "content": "你是一个专业的数据解析助手，擅长将非结构化文本转换成规范的JSON格式。"},
                        {"role": "user", "content": prompt}
                    ],
                    temperature=0.2,
                    max_tokens=4000,
                    response_format={"type": "json_object"}
                )
                
                parsed_content = response.choices[0].message.content
                parsed_data = json.loads(parsed_content)
                
                # 确保返回的是列表
                frames_data = parsed_data.get("frames", [])
                if not isinstance(frames_data, list):
                    frames_data = [frames_data]
                
                # 创建StoryboardFrame对象
                for i, frame_data in enumerate(frames_data):
                    # 将script的section关联到frame
                    script_section = script.sections[min(i, len(script.sections) - 1)]
                    
                    frame_id = f"frame_{uuid.uuid4().hex[:6]}"
                    frame_type = frame_data.get("frame_type", "keyframe")
                    shot_type = frame_data.get("shot_type", "medium")
                    
                    # 确保frame_type和shot_type是有效的枚举值
                    if frame_type not in [t.value for t in StoryboardFrameType]:
                        frame_type = "keyframe"
                    if shot_type not in [t.value for t in ShotType]:
                        shot_type = "medium"
                        
                    frame = StoryboardFrame(
                        id=frame_id,
                        script_section_id=script_section.id,
                        frame_type=StoryboardFrameType(frame_type),
                        shot_type=ShotType(shot_type),
                        description=frame_data.get("description", ""),
                        visual_description=frame_data.get("visual_description", ""),
                        dialogue=frame_data.get("dialogue"),
                        duration=float(frame_data.get("duration", 5.0)),
                        order=i,
                        camera_movement=frame_data.get("camera_movement"),
                        composition=frame_data.get("composition"),
                        comments=None,
                        metadata={}
                    )
                    frames.append(frame)
                    
            except Exception as e:
                self.logger.error(f"Error parsing storyboard text: {str(e)}")
                # 如果解析失败，创建一些基本的帧
                for i, section in enumerate(script.sections):
                    frame_id = f"frame_{uuid.uuid4().hex[:6]}"
                    frame = StoryboardFrame(
                        id=frame_id,
                        script_section_id=section.id,
                        frame_type=StoryboardFrameType.KEYFRAME,
                        shot_type=ShotType.MEDIUM,
                        description=f"Scene from section {i+1}",
                        visual_description=section.visual_description,
                        dialogue=None,
                        duration=section.duration / 2,  # 假设每个部分有两个关键帧
                        order=i,
                        camera_movement=None,
                        composition=None,
                        comments=None,
                        metadata={}
                    )
                    frames.append(frame)
        else:
            # 如果没有OpenAI客户端，为每个脚本部分创建基本帧
            for i, section in enumerate(script.sections):
                frame_id = f"frame_{uuid.uuid4().hex[:6]}"
                frame = StoryboardFrame(
                    id=frame_id,
                    script_section_id=section.id,
                    frame_type=StoryboardFrameType.KEYFRAME,
                    shot_type=ShotType.MEDIUM,
                    description=f"Scene from section {i+1}",
                    visual_description=section.visual_description,
                    dialogue=None,
                    duration=section.duration / 2,  # 假设每个部分有两个关键帧
                    order=i,
                    camera_movement=None,
                    composition=None,
                    comments=None,
                    metadata={}
                )
                frames.append(frame)
                
        return frames
    
    def _generate_mock_storyboard(self, script: Script, style: str) -> Storyboard:
        """
        生成模拟分镜（用于测试或无OpenAI时）
        
        Args:
            script: 脚本对象
            style: 分镜风格
            
        Returns:
            模拟分镜对象
        """
        self.logger.info("Generating mock storyboard for testing")
        
        storyboard_id = f"storyboard_{uuid.uuid4().hex[:8]}"
        frames = []
        
        for i, section in enumerate(script.sections):
            # 为每个部分创建2-3个帧
            num_frames = min(len(section.content) // 100 + 1, 3)
            num_frames = max(num_frames, 2)  # 至少2个
            
            for j in range(num_frames):
                frame_id = f"frame_{uuid.uuid4().hex[:6]}"
                
                # 随机选择帧类型
                frame_types = list(StoryboardFrameType)
                shot_types = list(ShotType)
                
                frame = StoryboardFrame(
                    id=frame_id,
                    script_section_id=section.id,
                    frame_type=frame_types[i % len(frame_types)],
                    shot_type=shot_types[j % len(shot_types)],
                    description=f"Frame {j+1} for section {i+1}: {section.content[:50]}...",
                    visual_description=f"Visual representation of {section.visual_description[:100]}...",
                    dialogue=None if j != 1 else f"Character: '{section.content.split(' ')[:10]}...'",
                    duration=section.duration / num_frames,
                    order=i * 10 + j,
                    camera_movement=None,
                    composition=None,
                    comments=None,
                    metadata={"mock": True}
                )
                frames.append(frame)
        
        # 计算总时长
        total_duration = sum(frame.duration for frame in frames)
        
        # 创建模拟分镜
        storyboard = Storyboard(
            id=storyboard_id,
            script_id=script.id,
            title=f"{script.title} Mock Storyboard",
            style=StoryboardStyle(style),
            frames=frames,
            transitions=[],
            images=[],
            total_duration=total_duration,
            creator_id=script.creator_id,
            status="draft",
            metadata={"mock": True}
        )
        
        return storyboard
